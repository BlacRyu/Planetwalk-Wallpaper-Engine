{
	"camera" : 
	{
		"center" : "0.00000 0.00000 -1.00000",
		"eye" : "0.00000 0.00000 0.00000",
		"up" : "0.00000 1.00000 0.00000"
	},
	"general" : 
	{
		"ambientcolor" : "0.30000 0.30000 0.30000",
		"bloom" : false,
		"bloomhdrfeather" : 0.1,
		"bloomhdriterations" : 8,
		"bloomhdrscatter" : 1.619,
		"bloomhdrstrength" : 2.0,
		"bloomhdrthreshold" : 1.0,
		"bloomstrength" : 2.0,
		"bloomthreshold" : 0.64999998,
		"camerafade" : true,
		"cameraparallax" : false,
		"cameraparallaxamount" : 0.0099999998,
		"cameraparallaxdelay" : 0.1,
		"cameraparallaxmouseinfluence" : 1.0,
		"camerapreview" : true,
		"camerashake" : false,
		"camerashakeamplitude" : 0.5,
		"camerashakeroughness" : 1.0,
		"camerashakespeed" : 3.0,
		"clearcolor" : "0.70000 0.70000 0.70000",
		"clearenabled" : true,
		"farz" : 10000.0,
		"fov" : 50.0,
		"hdr" : false,
		"nearz" : 0.0099999998,
		"orthogonalprojection" : 
		{
			"height" : 2160,
			"width" : 3840
		},
		"skylightcolor" : "0.30000 0.30000 0.30000",
		"zoom" : 1.0
	},
	"objects" : 
	[
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 7,
			"image" : "models/util/solidlayer.json",
			"locktransforms" : true,
			"name" : "OMGHelpers (script class)",
			"origin" : "-5.50000 0.00000 0.00000",
			"scale" : "0.00000 0.00000 0.00000",
			"size" : "512.00000 512.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport var scriptProperties = createScriptProperties()\n\t.addColor({\n\t\tname: 'debugText_FlashColor',\n\t\tlabel: 'Debug Flash Color',\n\t\tvalue: new Vec3(0.5, 1.0, 1.0)\n\t})\n\t.finish();\n\nlet bEnableDebugText = true;\nlet debugText_Layers = [];\n// let debugText_FlashColor = new Vec3(0.5, 1.0, 1.0);\nlet debugText_Color = new Vec3(1.0, 1.0, 1.0);\nlet debugText_ShowBackground = true;\nlet debugText_BackgroundColor = new Vec3(0.1, 0.1, 0.1);\nlet debugText_Size = 5;\nlet debugText_Alpha = 0.75;\nlet debugText_FlashScale = 1.01;\n/** How many milliseconds to fade from the flash color to the normal color when the text is updated. */\nlet debugText_FlashTime = 250;\n/** How many milliseconds to display the text before starting to fade out. */\nlet debugText_DisplayTime = 500;\n/** How many milliseconds to fade out the debug text before removing it. */\nlet debugText_FadeTime = 1500;\n\n\nlet _canvasToScreen = 1.0;\n\n\nexport function update() {\n\tlet currentTime = new Date().getTime();\n\tlet linesDisplayed = 0;\n\t\n\tdebugText_Layers.forEach(\n\t\tfunction(textLayer, index, array) {\n\t\t\tlet displayTime = textLayer.displayTime || debugText_DisplayTime;\n\t\t\tif (currentTime > textLayer.lastUpdated + (displayTime + debugText_FadeTime)) {\n\t\t\t\ttextLayer.alpha = 0;\n\t\t\t\tthisScene.destroyLayer(textLayer);\n\t\t\t\tarray.splice(index, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (currentTime > textLayer.lastUpdated + displayTime) {\n\t\t\t\ttextLayer.color = debugText_Color;\n\t\t\t\tlet fadeLerp = (currentTime - (textLayer.lastUpdated + displayTime)) / debugText_FadeTime;\n\t\t\t\ttextLayer.alpha = OMGHelpers.lerp(debugText_Alpha, 0, fadeLerp);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet flashLerp = OMGHelpers.clamp((currentTime - textLayer.lastChanged) / debugText_FlashTime);\n\t\t\t\ttextLayer.color = OMGHelpers.lerp(scriptProperties.debugText_FlashColor, debugText_Color, flashLerp);\n\t\t\t\ttextLayer.scale = new Vec3(OMGHelpers.lerp(debugText_FlashScale * _canvasToScreen, 1 * _canvasToScreen, flashLerp));\n\t\t\t\ttextLayer.alpha = debugText_Alpha;\n\t\t\t}\n\n\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\tlet cornerY = engine.canvasSize.y;\n\t\t\t\tlet cornerX = 0;\n\t\t\t\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\t\t\t\tif (screenAspectRatio > canvasAspectRatio) {\n\t\t\t\t\tcornerY = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\t\t\t\tcornerY += (engine.canvasSize.y - cornerY) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcornerX = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\t\t\t\tcornerX = (engine.canvasSize.x - cornerX) / 2;\n\t\t\t\t}\n\t\t\t\ttextLayer.origin = new Vec3(cornerX, cornerY - linesDisplayed * (debugText_Size * 4.9 - 0.5) * _canvasToScreen, 0);\n\t\t\t}\n\t\t\telse { // 3D Scene\n\t\t\t\tlet aspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\tlet up = ct.up;\n\t\t\t\tlet right = forward.cross(up);\n\t\t\t\tlet pos = ct.eye.add(forward).add(up.multiply(0.45)).add(right.multiply(-0.45 * aspectRatio));\n\t\t\t\tpos.y -= linesDisplayed * (debugText_Size * .002);\n\t\t\t\ttextLayer.origin = new Vec3(pos.x, pos.y, pos.z);\n\t\t\t\ttextLayer.scale = new Vec3(0.0005);\n\t\t\t}\n\t\t\ttextLayer.pointsize = debugText_Size;\n\t\t\ttextLayer.visible = bEnableDebugText;\n\t\t\tlinesDisplayed += textLayer.text.split('\\n').length;\n\t\t}\n\t);\n}\n\n\nexport function init() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\nexport function resizeScreen() {\n\t_canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n}\n\n\n\n\nclass OMGHelpers {\n\t/** Prints all key/value pairs present on the object to the console. */\n\tstatic printObjectValues(obj){\n\t\tif (typeof(obj) !== 'object' || obj === null)\n\t\t\treturn;\n\n\t\tfor (const key of Object.keys(obj))\n\t\t\tconsole.log(key + \" - \" + obj[key]);\n\t}\n\n\t/** Attempts to add two values together. */\n\tstatic add(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 + v2;\n\t\telse if (v1.add)\n\t\t\treturn v1.add(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to subtract the second value from the first value. */\n\tstatic subtract(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn v1;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 - v2;\n\t\telse if (v1.subtract)\n\t\t\treturn v1.subtract(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to multiply two values together. */\n\tstatic multiply(v1, v2) {\n\t\tif (v2 === undefined)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Attempts to divide the first value by the second value. */\n\tstatic divide(v1, v2) {\n\t\tif (!v2)\n\t\t\treturn undefined;\n\t\telse if (typeof v1 === 'number' || typeof v1 === 'string')\n\t\t\treturn v1 * v2;\n\t\telse if (v1.multiply)\n\t\t\treturn v1.multiply(v2);\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/**\n\t * True if the two parameters are the same type and contain equal values, otherwise false\n\t * @param [epsilon] {number} The minimum difference allowed between number values before they are considered non-equal (helps avoid some floating-point issues)\n\t * @return {boolean}\n\t */\n\tstatic equal(v1, v2, epsilon = 0.0001){\n\t\tif (v1 instanceof Vec3) {\n\t\t\tif (v2 instanceof Vec3)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon && Math.abs(v1.z - v1.z) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tif (v2 instanceof Vec2)\n\t\t\t\treturn (Math.abs(v1.x - v2.x) < epsilon && Math.abs(v1.y - v2.y) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\telse switch (typeof v1) {\n\t\tcase \"number\":\n\t\t\tif (typeof v2 === \"number\")\n\t\t\t\treturn (Math.abs(v1 - v2) < epsilon);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (v1 === v2);\n\t\t}\n\t}\n\n\t/** Restricts a value to remain between two boundary values. \n\t * @param {number} val - The value to be restricted.\n\t * @param {number} min - The lower bound.\n\t * @param {number} max - The upper bound.\n\t*/\n\tstatic clamp(val, min = 0, max = 1) {\n\t\tif (typeof(val) === \"number\")\n\t\t\treturn Math.min(max, Math.max(min, val));\n\t\telse if (val instanceof Vec2) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (val instanceof Vec3) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (val instanceof Vec4) {\n\t\t\tlet x = Math.min(max.x, Math.max(min.x, val.x));\n\t\t\tlet y = Math.min(max.y, Math.max(min.y, val.y));\n\t\t\tlet z = Math.min(max.z, Math.max(min.z, val.z));\n\t\t\tlet w = Math.min(max.w, Math.max(min.w, val.w));\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t}\n\n\t/** Interpolate linearly from the first value to the second based on the third (0 to 1) */\n\tstatic lerp(v1, v2, percent) {\n\t\tif (typeof(v1) === \"number\")\n\t\t\treturn v1 + (v2 - v1) * percent;\n\t\telse if (v1 instanceof Vec2) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\treturn new Vec2(x, y);\n\t\t}\n\t\telse if (v1 instanceof Vec3) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\treturn new Vec3(x, y, z);\n\t\t}\n\t\telse if (v1 instanceof Vec4) {\n\t\t\tlet x = v1.x + (v2.x - v1.x) * percent;\n\t\t\tlet y = v1.y + (v2.y - v1.y) * percent;\n\t\t\tlet z = v1.z + (v2.z - v1.z) * percent;\n\t\t\tlet w = v1.w + (v2.w - v1.w) * percent;\n\t\t\treturn new Vec4(x, y, z, w);\n\t\t}\n\t\telse\n\t\t\treturn undefined;\n\t}\n\n\t/** Prints a stack trace to the console. */\n\tstatic stackTrace() {\n\t\treturn console.log(new Error().stack);\n\t}\n\t\n\t/** Creates or updates a text layer in the corner of the screen. \n\t * @param {string} text - The text that the layer should display.\n\t * @param {string} name - The name of the text layer to create or update.\n\t * @param {number} displayTime - How many milliseconds the message should be displayed for.\n\t*/\n\tstatic debugText(text, name = \"_defaultLayerName\", displayTime = 5000) {\n\t\tif (bEnableDebugText && name !== undefined && text !== undefined) {\n\t\t\tlet layer = thisScene.getLayer(name.toString() + \"_debugText\");\n\t\t\tif (layer) {\n\t\t\t\tif (layer.text != text) {\n\t\t\t\t\tlayer.text = text;\n\t\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\t\tlayer.displayTime = displayTime;\n\t\t\t\t\tlayer.color = scriptProperties.debugText_FlashColor;\n\t\t\t\t\tlayer.scale = new Vec3(debugText_FlashScale * _canvasToScreen);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tlayer.lastUpdated = new Date().getTime();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet layerSettings = new Object();\n\t\t\t\tif (engine.canvasSize.x !== 0) {\n\t\t\t\t\tlayerSettings.origin = \"0, \" + (engine.canvasSize.y - debugText_Layers.length * (debugText_Size * 3 + 10)) + \", 0\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlet ct = thisScene.getCameraTransforms();\n\t\t\t\t\tlet forward = ct.center.subtract(ct.eye).normalize();\n\t\t\t\t\tlet up = ct.up;\n\t\t\t\t\tlet right = forward.cross(up);\n\t\t\t\t\tlet pos = new Vec3(0, .5, 0);//ct.eye.add(forward);//.add(right);\n\t\t\t\t\tlayerSettings.origin = `${pos.x}, ${pos.y}, ${pos.z}`;\n\t\t\t\t}\n\t\t\t\tlayerSettings.name = name.toString() + \"_debugText\";\n\t\t\t\tlayerSettings.text = text;\n\t\t\t\tlayerSettings.pointsize = debugText_Size;\n\t\t\t\tlayerSettings.font = \"systemfont_consolas\";\n\n\t\t\t\tlayerSettings.verticalalign = \"top\";\n\t\t\t\tlayerSettings.horizontalalign = \"left\";\n\t\t\t\tlayerSettings.color = scriptProperties.debugText_FlashColor.x + \", \" + scriptProperties.debugText_FlashColor.y + \", \" + scriptProperties.debugText_FlashColor.z;\n\t\t\t\tlayerSettings.opaquebackground = debugText_ShowBackground;\n\t\t\t\tlayerSettings.backgroundcolor = debugText_BackgroundColor;\n\t\t\t\tlayerSettings.padding = 0;\n\t\t\t\tlayerSettings.alpha = debugText_Alpha;\n\t\t\t\tlayer = thisScene.createLayer(layerSettings);\n\t\t\t\tlayer.lastChanged = layer.lastUpdated = new Date().getTime();\n\t\t\t\tlayer.displayTime = displayTime;\n\t\t\t\tdebugText_Layers.push(layer);\n\t\t\t}\n\t\t}\n\t}\n}\n\nshared.OMGHelpers = OMGHelpers;",
				"scriptproperties" : 
				{
					"debugText_FlashColor" : "0.49804 1.00000 1.00000"
				},
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 82,
			"image" : "models/util/solidlayer.json",
			"locktransforms" : true,
			"name" : "SurfaceSprite (script class)",
			"origin" : "960.00000 540.00000 0.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\nimport * as WEVector from 'WEVector';\n\n/**\n * Distance from the planet center to its surface.\n * @type {Number}\n */\nconst _planetRadius = 1153;\n\n/**\n * Default values used for a surface sprite if they aren't defined when constructing\n */\nconst defaultSpriteProperties = {\n\tname : \"SurfaceSprite\",\n\timage : \"models/sCommandoWalk_0.json\",\n\talignment : \"bottom\",\n\tscale : \"3 3 3\",\n\torigin : `${_planetRadius} 0 0`,\n\tangles : `0 0 ${-Math.PI / 2.0}`,\n}\n\nclass SurfaceSprite {\n\t/**\n\t * Distance from the planet center to its surface.\n\t * @type {Number}\n\t */\n\tstatic planetRadius = _planetRadius;\n\t\n\t/**\n\t * The root transform layer that controls the planet's position but not its rotation.\n\t * @type ILayer\n\t */\n\tget planetRoot() {\n\t\treturn SurfaceSprite._planetRoot || (SurfaceSprite._planetRoot = thisScene.getLayer(\"Planet Root\"));\n\t}\n\n\t/**\n\t * The image layer for the planet. Parent to this to follow the planet's rotation.\n\t * @type ILayer\n\t */\n\tget planetLayer() {\n\t\treturn SurfaceSprite._planetLayer || (SurfaceSprite._planetLayer = thisScene.getLayer(\"Planet\"));\n\t}\n\n\tget name() {\n\t\treturn this.spriteLayer.name;\n\t}\n\n\t/**\n\t * If true, this sprite will ignore the planet's rotation\n\t * @type Boolean\n\t */\n\tset isStationary(shouldBeStationary) {\n\t\tif (shouldBeStationary) {\n\t\t\tthis.rootLayer.setParent(this.planetRoot, true);\n\t\t}\n\t\telse {\n\t\t\tthis.rootLayer.setParent(this.planetLayer, true);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the angle around the planet at which the sprite is located.\n\t * @param {Number} angle - The surface angle in degrees at which the sprite should be moved to. 0 is to the right.\n\t */\n\tsetAngle(angle) {\n\t\tthis.rootLayer.angles = new Vec3(0, 0, angle - this.rootLayer.getParent().angles.z);\n\t}\n\n\t/** \n\t * Moves the sprite to a location on the planet surface nearest to the given location.\n\t * @param {Vec2} target - The canvas position nearest to where we want the sprite to be placed.\n\t */\n\tmoveTo(target) {\n\t\tlet targetAngle = WEVector.vectorAngle2(target.subtract(this.planetRoot));\n\t\tsetAngle(targetAngle);\n\t}\n\n\t/**\n\t * @param {Object} spriteProperties - Property definitions for the sprite layer\n\t * @param {Boolean} isStationary - If true the sprite will ignore the planet's rotation.\n\t * @param {Number} angle - The initial angle around the planet in degrees at which the sprite will be placed. An angle of 0 would be on the right side of the planet.\n\t */\n\tconstructor(spriteProperties, isStationary = false, angle = 90) {\n\t\t// Create sprite layer\n\t\tthis.spriteLayer = thisScene.createLayer( {\n\t\t\t\t...defaultSpriteProperties,\n\t\t\t\t...spriteProperties\n\t\t\t}\n\t\t)\n\t\t// Create root layer\n\t\tthis.rootLayer = thisScene.createLayer( {\n\t\t\t\tname : this.spriteLayer.name + \"_root\",\n\t\t\t\torigin : this.planetRoot.origin\n\t\t\t}\n\t\t)\n\t\t// Set up heirarchy\n\t\tthis.spriteLayer.setParent(this.rootLayer, false);\n\t\tthis.isStationary = isStationary; // isStationary's set function binds root layer to planet.\n\t\tthisScene.sortLayer(this.spriteLayer, thisScene.getLayerIndex(this.planetLayer) + 1);\n\t\tthis.setAngle(angle);\n\t}\n\n\tdestroy() {\n\t\tthisScene.destroyLayer(this.spriteLayer);\n\t\tthisScene.destroyLayer(this.rootLayer);\n\t}\n}\nshared.SurfaceSprite = SurfaceSprite;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 76,
			"image" : "models/util/solidlayer.json",
			"locktransforms" : true,
			"name" : "SurvivorSprite (script class)",
			"origin" : "960.00000 540.00000 0.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\nimport * as WEVector from 'WEVector';\nconst SurfaceSprite = shared.SurfaceSprite;\n\n/**\n * Degrees of separation between each survivor when playing in co-op mode.\n */\nconst survivorSpacing = 5.0;\n\n/**\n * Returns the default scale for the given survivor name\n * @param {String} survivorName - The name of the survivor whose scale we want to find\n * @return {Number} The default scale of the specified survivor\n */\nfunction getSurvivorScale(survivorName) {\n\tswitch (survivorName) {\n\t\t// case \"providence\":\n\t\t// \treturn 2;\n\t\tdefault:\n\t\t\treturn 3;\n\t}\n}\n\n/**\n * Returns an optional offset for the survivors sprite position. Relative to when standing the right side of the planet, so x will move up and y will move left.\n * @param {String} survivorName - The name of the survivor whose offset we want to find\n * @return {Vec3} The position offset of the specified survivor\n */\nfunction getSurvivorOffset(survivorName) {\n\tswitch (survivorName) {\n\t\tcase \"acrid\":\n\t\t\treturn new Vec3(0, 25, 0);\n\t\tcase \"providence\":\n\t\t\treturn new Vec3(-5, 55, 0);\n\t\tcase \"mercenary\":\n\t\t\treturn new Vec3(0, 20, 0);\n\t\tcase \"chef\":\n\t\t\treturn new Vec3(-35, 0, 0);\n\t\tcase \"artificer\":\n\t\t\treturn new Vec3(20, 10, 0);\n\t\tcase \"hand\":\n\t\t\treturn new Vec3(0, 20, 0);\n\t\tcase \"drifter\":\n\t\t\treturn new Vec3(0, 10, 0);\n\t\tcase \"lizard\":\n\t\t\treturn new Vec3(0, 10, 0);\n\t\tcase \"enforcer\":\n\t\t\treturn new Vec3(0, -5, 0);\n\t\tcase \"bandit\":\n\t\t\treturn new Vec3(0, -5, 0);\n\t\tcase \"sniper\":\n\t\t\treturn new Vec3(0, -15, 0);\n\t\tdefault:\n\t\t\treturn new Vec3(0, 0, 0);\n\t}\n}\n\nfunction isValidSurvivor(survivorName) {\n\treturn shared.survivorNames.includes(survivorName);\n}\n\nclass SurvivorSprite extends SurfaceSprite {\n\t/**\n\t * List of all active survivor Sprites.\n\t * @type {Object.<String, SurvivorSprite>}\n\t */\n\tstatic _activeSurvivors = {};\n\n\t/**\n\t * Add a survivor to the planet.\n\t */\n\tstatic addSurvivor(survivorName) {\n\t\tif (!isValidSurvivor(survivorName)) {\n\t\t\tconsole.log(`Error: Attempted to add a non-existent survivor (${survivorName}).`);\n\t\t\treturn undefined;\n\t\t}\n\t\tif (SurvivorSprite._activeSurvivors[survivorName] === undefined) {\n\t\t\tSurvivorSprite._activeSurvivors[survivorName] = new SurvivorSprite(survivorName);\n\t\t}\n\t\tthis.repositionSurvivors();\n\t\treturn SurvivorSprite._activeSurvivors[survivorName];\n\t}\n\n\t/**\n\t * Remove a survivor from the planet.\n\t */\n\tstatic removeSurvivor(survivorName) {\n\t\tif (SurvivorSprite._activeSurvivors[survivorName] !== undefined) {\n\t\t\tSurvivorSprite._activeSurvivors[survivorName].destroy();\n\t\t}\n\t\tthis.repositionSurvivors();\n\t}\n\n\t/**\n\t * Replaces any and all current survivors with the given survivor.\n\t */\n\tstatic setSurvivor(survivorName) {\n\t\tif (!isValidSurvivor(survivorName)) {\n\t\t\tconsole.log(`Error: Attempted to set a non-existent survivor (${survivorName}).`);\n\t\t\treturn undefined;\n\t\t}\n\t\tthis.clearSurvivors();\n\t\tSurvivorSprite._activeSurvivors[survivorName] = new SurvivorSprite(survivorName);\n\t\tthis.repositionSurvivors();\n\t\treturn SurvivorSprite._activeSurvivors[survivorName];\n\t}\n\n\t/**\n\t * Adjusts the positions of all survivors so they are evenly spaced on top of the planet.\n\t */\n\tstatic repositionSurvivors() {\n\t\tlet numSurvivors = Object.values(SurvivorSprite._activeSurvivors).length;\n\t\tlet i = 0;\n\t\tlet angle = 90 + survivorSpacing * (numSurvivors - 1) / 2;\n\t\tfor (const survivor of Object.values(SurvivorSprite._activeSurvivors)) {\n\t\t\tsurvivor.setAngle(angle);\n\t\t\tangle -= survivorSpacing;\n\t\t\t++i;\n\t\t}\n\t}\n\n\t/**\n\t * Removes all survivors from the scene.\n\t */\n\tstatic clearSurvivors() {\n\t\tfor (const survivor of Object.values(SurvivorSprite._activeSurvivors)) {\n\t\t\tsurvivor.destroy();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Object} spriteProperties - Property definitions for the sprite layer\n\t * @param {Boolean} isStationary - If true the sprite will ignore the planet's rotation.\n\t * @param {Number} angle - The initial angle around the planet in degrees at which the sprite will be placed. An angle of 0 would be on the right side of the planet.\n\t */\n\tconstructor(survivorName) {\n\t\tlet scale = getSurvivorScale(survivorName).toString();\n\t\tlet origin = getSurvivorOffset(survivorName).add(new Vec3(SurfaceSprite.planetRadius, 0, 0));\n\t\tlet spriteProperties = {\n\t\t\tname : survivorName,\n\t\t\tscale : `${scale} ${scale} ${scale}`,\n\t\t\timage : `models/${survivorName}_Walk.json`,\n\t\t\torigin : origin.toString(),\n\t\t}\n\t\tsuper(spriteProperties, true, 90);\n\n\t\tSurvivorSprite._activeSurvivors[survivorName] = this;\n\t}\n\n\tdestroy() {\n\t\tdelete SurvivorSprite._activeSurvivors[this.name];\n\t\tsuper.destroy();\n\t}\n}\nshared.SurvivorSprite = SurvivorSprite;",
				"value" : false
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 15,
			"image" : "models/util/solidlayer.json",
			"locktransforms" : true,
			"name" : "Shared logic (script)",
			"origin" : "960.00000 540.00000 0.00000",
			"size" : "0.00000 0.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\nconst SurfaceSprite = shared.SurfaceSprite;\nconst SurvivorSprite = shared.SurvivorSprite;\n\n/**\n * The names of each available survivor.\n * @type String[]\n */\nconst survivorNames = [\n\t\"commando\",\n\t\"huntress\",\n\t\"enforcer\",\n\t\"bandit\",\n\t\"hand\",\n\t\"engineer\",\n\t\"miner\",\n\t\"sniper\",\n\t\"acrid\",\n\t\"mercenary\",\n\t\"loader\",\n\t\"chef\",\n\t\"pilot\",\n\t\"artificer\",\n\t\"drifter\",\n\t\"robomando\",\n\t\"providence\",\n\t\"lizard\",\n];\nshared.survivorNames = survivorNames;\n\nengine.registerAsset(\"models/commando_walk.json\");\nengine.registerAsset(\"models/huntress_walk.json\");\nengine.registerAsset(\"models/enforcer_walk.json\");\nengine.registerAsset(\"models/bandit_walk.json\");\nengine.registerAsset(\"models/hand_walk.json\");\nengine.registerAsset(\"models/engineer_walk.json\");\nengine.registerAsset(\"models/miner_walk.json\");\nengine.registerAsset(\"models/sniper_walk.json\");\nengine.registerAsset(\"models/acrid_walk.json\");\nengine.registerAsset(\"models/mercenary_walk.json\");\nengine.registerAsset(\"models/loader_walk.json\");\nengine.registerAsset(\"models/chef_walk.json\");\nengine.registerAsset(\"models/pilot_walk.json\");\nengine.registerAsset(\"models/artificer_walk.json\");\nengine.registerAsset(\"models/drifter_walk.json\");\nengine.registerAsset(\"models/robomando_walk.json\");\nengine.registerAsset(\"models/providence_walk.json\");\nengine.registerAsset(\"models/lizard_walk.json\");\n\n/** Integer value representing the current planet biome. */\nconst BiomeType = {\n\tAncientValley : 0,\n\tAncientValleySnow : 1,\n\tDampCaverns : 2,\n\tDampCaverns2 : 3,\n\tDesolateForest : 4,\n\tDriedLake : 5,\n\tDriedLake2 : 6,\n\tHiveCluster : 7,\n\tMagmaBarracks : 8,\n\tRiskOfRain : 9,\n\tSkyMeadow : 10,\n\tSunkenTombs : 11,\n\tTempleOfTheElders : 12,\n\tTempleOfTheElders2 : 13,\n}\nshared.BiomeType = BiomeType;\n\n\n\n/** How fast the background scrolls. */\nshared.bgSpeed = new Vec2(-0.003, 0.0);\n\n/** The currently active biome. */\nshared.biome = BiomeType.RiskOfRain;\n\n/** How fast the planet rotates. */\nshared.planetSpeed = 1.75;\n\n/** The vertical position of the planet's center */\nshared.planetHeight = -865\n\n\n/** Whether we are in co-op mode or not. */\nlet coOpEnabled = undefined;\n\n/** The selected survivor for single player mode. */\nlet singleSurvivor = undefined;\n\n/** The selected survivors for co-op mode. */\nlet survivorSelected = {};\nsurvivorNames.forEach(name => survivorSelected[name] = undefined);\n\n\n/** \n * Coordinates that correspond to the horizontal extents of the visible part of the wallpaper based on the current display's aspect ratio. \n * @type Vec2\n*/\nshared.screenBoundsX = undefined;\n/** \n * Canvas coordinates that correspond to the vertical extents of the visible part of the wallpaper based on the current display's aspect ratio. \n * @type Vec2\n*/\nshared.screenBoundsY = undefined;\n/** \n * Multiply scale by this value to make sure an object's pixel dimensions do not change when the screen dimensions change.\n * @type number\n */\nshared.canvasToScreen = undefined;\n\nfunction calculateCanvasBounds() {\n\tshared.canvasToScreen = Math.min(engine.canvasSize.x / engine.screenResolution.x, engine.canvasSize.y / engine.screenResolution.y);\n\t\n\tshared.zoom = engine.screenResolution.y < 800 || engine.screenResolution.x < 1200 ? 2 : 3;\n\n\tlet screenAspectRatio = engine.screenResolution.x / engine.screenResolution.y;\n\tlet canvasAspectRatio = engine.canvasSize.x / engine.canvasSize.y;\n\tif (screenAspectRatio > canvasAspectRatio) {\n\t\tlet height = engine.screenResolution.y * engine.canvasSize.x / engine.screenResolution.x;\n\t\tlet cornerOffset = (engine.canvasSize.y - height) / 2;\n\t\tshared.screenBoundsX = new Vec2(0, engine.canvasSize.x);\n\t\tshared.screenBoundsY = new Vec2(cornerOffset, engine.canvasSize.y - cornerOffset);\n\t}\n\telse {\n\t\tlet width = engine.screenResolution.x * engine.canvasSize.y / engine.screenResolution.y;\n\t\tlet cornerOffset = (engine.canvasSize.x - width) / 2;\n\t\tshared.screenBoundsX = new Vec2(cornerOffset, engine.canvasSize.x - cornerOffset);\n\t\tshared.screenBoundsY = new Vec2(0, engine.canvasSize.y);\n\t}\n}\n\nexport function init() {\n\tcalculateCanvasBounds();\n}\n\nexport function resizeScreen() {\n\tcalculateCanvasBounds();\n}\n\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\t// Planet height\n\tif (changedUserProperties.planet_height !== undefined) {\n\t\tshared.planetHeight = changedUserProperties.planet_height * 400.0 - 1265.0;\n\t}\n\n\t// Biome\n\tif (changedUserProperties.biome !== undefined) {\n\t\tshared.biome = Number(changedUserProperties.biome);\n\t}\n\n\t// Single Survivor\n\tif (changedUserProperties.character !== undefined && changedUserProperties.character !== singleSurvivor)\n\t{\n\t\tsingleSurvivor = changedUserProperties.character;\n\t\tif (!coOpEnabled)\n\t\t{\n\t\t\tif (singleSurvivor !== \"none\") {\n\t\t\t\tSurvivorSprite.setSurvivor(singleSurvivor);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSurvivorSprite.clearSurvivors();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Co-op mode\n\tif (changedUserProperties.coop !== undefined && changedUserProperties.coop !== coOpEnabled) {\n\t\tcoOpEnabled = changedUserProperties.coop;\n\t\tif (coOpEnabled) {\n\t\t\tSurvivorSprite.clearSurvivors();\n\t\t\tfor (let name of survivorNames) {\n\t\t\t\tif (survivorSelected[name]) {\n\t\t\t\t\tSurvivorSprite.addSurvivor(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tSurvivorSprite.setSurvivor(singleSurvivor);\n\t\t}\n\t}\n\n\t// Co-op survivor\n\tfor (let name of survivorNames) {\n\t\tif (changedUserProperties[name] !== undefined) {\n\t\t\tif (changedUserProperties[name] == true && !survivorSelected[name]) {\n\t\t\t\tsurvivorSelected[name] = true;\n\t\t\t\tif (coOpEnabled) {\n\t\t\t\t\tSurvivorSprite.addSurvivor(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (changedUserProperties[name] == false && survivorSelected[name]) {\n\t\t\t\tsurvivorSelected[name] = false;\n\t\t\t\tif (coOpEnabled) {\n\t\t\t\t\tSurvivorSprite.removeSurvivor(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
				"value" : false
			}
		},
		{
			"id" : 23,
			"locktransforms" : true,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : true,
			"name" : "Silence (Enables volume slider)",
			"origin" : "-100.00000 -100.00000 0.00000",
			"playbackmode" : "loop",
			"sound" : [],
			"startsilent" : true,
			"volume" : 0.5
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/transform/effect.json",
					"id" : 20,
					"name" : "Tile + Scroll",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"angle" : 0.0,
								"offset" : 
								{
									"script" : "'use strict';\n\n/**\n * @param {Vec2} value - for property 'offset'\n * @return {Vec2} - update current property value\n */\nexport function update(value) {\n\treturn value.add(shared.bgSpeed.multiply(engine.frametime));\n}\n",
									"value" : "0.00000 0.00000"
								},
								"scale" : "3.25 3.25"
							},
							"id" : 21
						}
					],
					"visible" : true
				}
			],
			"id" : 16,
			"image" : "models/bTitlescreen_0.json",
			"name" : "Background stars",
			"origin" : "1920.00000 1080.00000 0.00000",
			"parallaxDepth" : "0.05000 0.05000",
			"scale" : "10.00000 10.00000 10.00000",
			"size" : "1024.00000 580.00000",
			"solid" : true
		},
		{
			"id" : 104,
			"instanceoverride" : null,
			"name" : "Shooting_stars",
			"origin" : "1920.00000 1080.00000 0.00000",
			"particle" : "particles/Shooting_stars.json"
		},
		{
			"id" : 115,
			"instanceoverride" : 
			{
				"count" : 1.1,
				"id" : 116
			},
			"name" : "Shooting_stars",
			"origin" : "1920.00000 1080.00000 0.00000",
			"particle" : "particles/Shooting_stars.json"
		},
		{
			"id" : 64,
			"name" : "Root of Rain",
			"origin" : 
			{
				"animation" : 
				{
					"c0" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c1" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -0.0,
								"y" : -7.2574849
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 0,
								"y" : 7.2574849
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : -300
						},
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1.9192886,
								"y" : -0.72215569
							},
							"frame" : 60,
							"front" : 
							{
								"enabled" : true,
								"x" : 1.9192886,
								"y" : 0.72215569
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"c2" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1,
								"y" : 0
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1,
								"y" : 0
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						}
					],
					"options" : 
					{
						"fps" : 30,
						"length" : 60,
						"mode" : "single",
						"wraploop" : null
					}
				},
				"value" : "0.00000 0.00000 0.00000"
			}
		},
		{
			"angles" : "0.00000 -0.00000 0.00000",
			"id" : 106,
			"name" : "Title Root",
			"origin" : 
			{
				"script" : "'use strict';\n\nconst slideSpeed = 5.0;\n\nlet targetHeight = undefined;\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.title_height !== undefined)\n\t\ttargetHeight = changedUserProperties.title_height * 2160;\n}\n\nexport function update() {\n\tlet target = new Vec3(1920, targetHeight, 0);\n\tlet delta = target.subtract(thisLayer.origin);\n\tthisLayer.origin = thisLayer.origin.add(delta.multiply(Math.min(engine.frametime * slideSpeed, 0.1)));\n}\n",
				"value" : "1920.00000 1080.00000 0.00000"
			},
			"parent" : 64,
			"scale" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\nconst interpSpeed = 5.0;\n\n/** The smallest width the viewport can be before we have to start shrinking the title. */\nconst minWidth = 1900;\n\nlet userScale = 1.0;\n\nexport function update() {\n\tlet screenWidth = Math.min(minWidth, shared.screenBoundsX.y - shared.screenBoundsX.x);\n\tlet targetScale = screenWidth / minWidth * userScale;\n\tthisLayer.scale = new Vec3(thisLayer.scale.x + (targetScale - thisLayer.scale.x) * Math.min(0.1, engine.frametime * interpSpeed));\n}\n\n// export function init() {\n// \tadjustScale();\n// }\n\n// export function resizeScreen() {\n// \tadjustScale();\n// }\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.title_size !== undefined) {\n\t\tuserScale = changedUserProperties.title_size;\n\t\t// adjustScale();\n\t}\n}\n",
				"value" : "1.00000 1.00000 1.00000"
			},
			"visible" : 
			{
				"user" : "show_title",
				"value" : true
			}
		},
		{
			"angles" : "0.00000 -0.00000 0.00000",
			"id" : 85,
			"instanceoverride" : null,
			"name" : "Title pixels right",
			"parent" : 106,
			"particle" : "particles/Title_Pixels.json",
			"scale" : "3.00000 3.00000 1.00000"
		},
		{
			"angles" : "0.00000 -0.00000 3.14159",
			"id" : 101,
			"instanceoverride" : null,
			"name" : "Title pixels left",
			"parent" : 106,
			"particle" : "particles/Title_Pixels.json",
			"scale" : "3.00000 3.00000 1.00000"
		},
		{
			"alignment" : "center",
			"alpha" : 
			{
				"animation" : 
				{
					"c0" : 
					[
						{
							"back" : 
							{
								"enabled" : true,
								"x" : -1.1315579,
								"y" : 0.0032466024
							},
							"frame" : 0,
							"front" : 
							{
								"enabled" : true,
								"x" : 1.1315579,
								"y" : -0.0032466024
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 0
						},
						{
							"back" : 
							{
								"enabled" : false,
								"x" : 0,
								"y" : -0.086227544
							},
							"frame" : 30,
							"front" : 
							{
								"enabled" : false,
								"x" : 0,
								"y" : 0.086227544
							},
							"lockangle" : true,
							"locklength" : true,
							"value" : 1
						}
					],
					"options" : 
					{
						"fps" : 30,
						"length" : 30,
						"mode" : "single",
						"name" : "Fade in",
						"wraploop" : null
					}
				},
				"value" : 1.0
			},
			"angles" : "0.00000 -0.00000 0.00000",
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"id" : 83,
			"image" : "models/sTitle_0.json",
			"name" : "Title",
			"parallaxDepth" : "2.00000 2.00000",
			"parent" : 106,
			"scale" : "3.00000 3.00000 3.00000",
			"size" : "692.00000 163.00000",
			"solid" : true
		},
		{
			"angles" : "0.00000 -0.00000 0.00000",
			"id" : 119,
			"name" : "Planet Root",
			"origin" : 
			{
				"script" : "'use strict';\nconst Helpers = shared.OMGHelpers;\n\nconst slideSpeed = 5.0;\n\n// function adjustPosition() {\n// \tthisLayer.origin = new Vec3(1920, shared.screenBoundsY.x + shared.planetHeight, 0);\n// }\n\n// export function init() {\n// \tadjustPosition();\n// }\n\n// export function resizeScreen() {\n// \tadjustPosition();\n// }\n\n// export function applyUserProperties(changedUserProperties) {\n// \tadjustPosition();\n// }\n\n\n\nexport function update() {\n\tlet target = new Vec3(1920, shared.screenBoundsY.x + shared.planetHeight, 0);\n\tlet delta = target.subtract(thisLayer.origin);\n\tthisLayer.origin = thisLayer.origin.add(delta.multiply(Math.min(engine.frametime * slideSpeed, 0.1)));\n}\n",
				"value" : "1920.00000 -865.00000 0.00000"
			},
			"parent" : 64
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"angles" : 
			{
				"script" : "'use strict';\n\n/**\n * @param {Vec3} value - for property 'Angles'\n * @return {Vec3} - update current property value\n */\nexport function update(value) {\n\treturn value.add(new Vec3(0.0, 0.0, shared.planetSpeed * engine.frametime));\n}\n",
				"value" : "0.00000 -0.00000 0.00000"
			},
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/polar_transform/effect.json",
					"id" : 132,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"UV Offset" : "0.00000 0.00000",
								"UV Scale" : "-44 1.4"
							},
							"id" : 0
						}
					],
					"visible" : true
				}
			],
			"id" : 98,
			"image" : "models/sGroundStripSpriteSheet.json",
			"name" : "Planet",
			"parent" : 119,
			"scale" : "40.00000 6.51400 1.00000",
			"size" : "64.00000 393.00000",
			"solid" : true,
			"visible" : 
			{
				"script" : "'use strict';\n\nexport function init() {\n\tthisLayer.getTextureAnimation().pause();\n\tthisLayer.getTextureAnimation().setFrame(shared.biome);\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tthisLayer.getTextureAnimation().setFrame(shared.biome);\n}\n",
				"value" : true
			}
		},
		{
			"alignment" : "center",
			"alpha" : 1.0,
			"brightness" : 1.0,
			"color" : "1.00000 1.00000 1.00000",
			"colorBlendMode" : 0,
			"copybackground" : true,
			"effects" : 
			[
				{
					"file" : "effects/workshop/2078835426/pixelate/effect.json",
					"id" : 77,
					"name" : "",
					"passes" : 
					[
						{
							"constantshadervalues" : 
							{
								"new_resolution" : "1280 720",
								"resolution_scale" : 
								{
									"script" : "'use strict';\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.pixelscale !== undefined)\n\t\tthisObject.resolution_scale = 1.0 / changedUserProperties.pixelscale;\n}\n",
									"value" : 0.5
								}
							},
							"id" : 78
						}
					],
					"visible" : 
					{
						"user" : "pixelate",
						"value" : true
					}
				}
			],
			"id" : 74,
			"image" : "models/util/fullscreenlayer.json",
			"name" : "Post-Processing Layer",
			"parallaxDepth" : "0.00000 0.00000",
			"solid" : true
		},
		{
			"id" : 146,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : true,
			"name" : "musicTitle.ogg",
			"playbackmode" : "loop",
			"sound" : [ "sounds/musicTitle.ogg" ],
			"startsilent" : false,
			"volume" : 
			{
				"script" : "'use strict';\n\nconst title = \"musicTitle\"\nlet desiredVolume = 0.001;\nlet fadeRate = 2.0\n\n/**\n * @param {Number} value - for property 'volume'\n * @return {Number} - update current property value\n */\nexport function update(value) {\n\tif (desiredVolume > value) {\n\t\treturn Math.min(desiredVolume, value + fadeRate * engine.frametime);\n\t}\n\tif (desiredVolume < value) {\n\t\treturn Math.max(desiredVolume, value - fadeRate * engine.frametime);\n\t}\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.music !== undefined) {\n\t\tif (changedUserProperties.music == title)\n\t\t\tdesiredVolume = 0.5;\n\t\telse\n\t\t\tdesiredVolume = 0.001;\n\t}\n}\n",
				"value" : 0.001
			}
		},
		{
			"angles" : "0.00000 -0.00000 0.00000",
			"id" : 147,
			"maxtime" : 5.0,
			"mintime" : 1.0,
			"muteineditor" : true,
			"name" : "musicTitle2.ogg",
			"playbackmode" : "loop",
			"sound" : [ "sounds/musicTitle2.ogg" ],
			"startsilent" : false,
			"volume" : 
			{
				"script" : "'use strict';\n\nconst title = \"musicTitle2\"\nlet desiredVolume = 0.001;\nlet fadeRate = 2.0\n\n/**\n * @param {Number} value - for property 'volume'\n * @return {Number} - update current property value\n */\nexport function update(value) {\n\tif (desiredVolume > value) {\n\t\treturn Math.min(desiredVolume, value + fadeRate * engine.frametime);\n\t}\n\tif (desiredVolume < value) {\n\t\treturn Math.max(desiredVolume, value - fadeRate * engine.frametime);\n\t}\n}\n\n/**\n * @param {Object} changedUserProperties - only includes user properties that were recently changed!\n */\nexport function applyUserProperties(changedUserProperties) {\n\tif (changedUserProperties.music !== undefined) {\n\t\tif (changedUserProperties.music == title)\n\t\t\tdesiredVolume = 0.5;\n\t\telse\n\t\t\tdesiredVolume = 0.001;\n\t}\n}\n",
				"value" : 0.001
			}
		}
	],
	"version" : 2
}